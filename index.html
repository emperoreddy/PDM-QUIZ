<!DOCTYPE html>
<html lang="ro">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quiz Interactiv - Răspuns Multiplu</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .correct-answer-display {
            background-color: #d4edda; /* Verde deschis */
            border-left: 5px solid #28a745;
        }
        .option-label.selected {
            background-color: #cfe2ff;
            border-color: #0d6efd;
        }
        .option-label.correct {
            background-color: #d1e7dd;
            border-color: #198754;
        }
        .option-label.incorrect {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col items-center justify-center p-4">

    <div class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-3xl">
        <h1 class="text-2xl md:text-3xl font-bold text-center text-gray-800 mb-6">Test Grilă - Baze de Date</h1>
        
        <div id="quiz-container">
            <!-- Întrebările vor fi generate aici de JavaScript -->
        </div>

        <div id="navigation-buttons" class="mt-8 flex justify-between">
            <button id="prev-button" class="bg-blue-500 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow focus:outline-none focus:ring-2 focus:ring-blue-300 disabled:opacity-50" disabled>
                Anterior
            </button>
            <button id="next-button" class="bg-blue-500 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow focus:outline-none focus:ring-2 focus:ring-blue-300">
                Următor
            </button>
        </div>
        <div id="result-container" class="mt-6 text-center text-xl font-semibold text-gray-700"></div>
    </div>

    <script>
        // Datele pentru quiz extrase și verificate din "Grile MBD_merged.pdf"
        const quizData = [
            {
                question: "Algoritmul NESTED LOOP JOINS:",
                options: [
                    "Este aplicat doar pe tabele indexate",
                    "Se poate utiliza prin specificarea directive USE_NESTED",
                    "Conduce la marirea tipului de raspuns prin parcurgeri imbricate",
                    "Este aplicat numai pe jonctiuni intre doua tabele",
                    "Se poate utiliza prin specificarea directive USE_NL"
                ],
                correctAnswers: ["Se poate utiliza prin specificarea directive USE_NL", "Conduce la marirea tipului de raspuns prin parcurgeri imbricate"]
            },
            {
                question: "Printre etapele parcurse in lucrarea volumelor mari de date se regasesc:",
                options: [
                    "Transformarea variabilelor categoriale",
                    "Stocarea datelor in baze de date relationale",
                    "Reducerea volumului datelor prelucrate",
                    "Tratarea valorilor lipsa"
                ],
                correctAnswers: ["Transformarea variabilelor categoriale", "Reducerea volumului datelor prelucrate", "Tratarea valorilor lipsa"]
            },
            {
                question: "In MongoDB:",
                options: [
                    "Pentru agregarea datelor se utilizeaza metoda aggregate()",
                    "Datele sunt organizate sub forma de cheie-valoare",
                    "Pentru regasirea datelor se utilizeaza find(), projection() si sort()",
                    "In cazul agregarilor criteriile de colectie se precieaza in clauza find()"
                ],
                correctAnswers: ["Pentru agregarea datelor se utilizeaza metoda aggregate()", "Pentru regasirea datelor se utilizeaza find(), projection() si sort()"]
            },
            {
                question: "Bazele de date NoSQL:",
                options: [
                    "Stocheaza date nestructurate cu schema normalizata",
                    "Pot fi organizate sub forma de cheie valoare",
                    "Nu ofera posibilitatea de a replica si distribui datele pe mai multe servere",
                    "Implementeaza complet modelul ACID",
                    "Pot fi scalate pe orizontal pe mai multe servere"
                ],
                correctAnswers: ["Pot fi organizate sub forma de cheie valoare", "Pot fi scalate pe orizontal pe mai multe servere"]
            },
            {
                question: "Metodele de analiza perspectiva:",
                options: [
                    "Presupun aplicarea metodelor matematice si computationale pentru determinarea unor optiuni de decizie",
                    "Utilizeaza preponderant algoritmi de tip machine Learning",
                    "Sunt utilizate pentru a prezice tendintele si tiparele de comportament",
                    "Furnizeaza actiunile necesare pentru a obtine rezultatele previzibile, cat si efectele si implicatiile fiecarei optiuni decizionale"
                ],
                correctAnswers: ["Utilizeaza preponderant algoritmi de tip machine Learning", "Sunt utilizate pentru a prezice tendintele si tiparele de comportament"]
            },
            {
                question: "Tehnica de partitionare:",
                options: [
                    "Partitiile nu trebuie specificate in momentul in care este create tabela",
                    "Este o tehnica de grupare fizica a doua sau mai multe tabele, relative la una sau mai multe coloane",
                    "Inregistrarile noi sunt repartizate in partitia de care apartin prin specificarea clauzei partition",
                    "Este utilizta pentru gruparea logica a valorilor dintr-o anumita coloana dintr-o tabela",
                    "In cazul opartitiilor de tip List se utilizeaza algoritmul hash pentru repartizare"
                ],
                correctAnswers: ["Inregistrarile noi sunt repartizate in partitia de care apartin prin specificarea clauzei partition"]
            },
            {
                question: "In cazul optimizarilor SQL:",
                options: [
                    "Se determina modul de creare a tabelelor",
                    "Pentru determinarea costului de executie se iau in considerare operatiile I/O, CPU, memoria necesara",
                    "Optimizatorul utilizeaza statisticile colectate la nivelul bazei de date pentru construirea planului de executie",
                    "Se determina planul de executie cu un cost redus",
                    "Se urmareste construirea partitiilor pentru actualizarea datelor"
                ],
                correctAnswers: ["Pentru determinarea costului de executie se iau in considerare operatiile I/O, CPU, memoria necesara", "Optimizatorul utilizeaza statisticile colectate la nivelul bazei de date pentru construirea planului de executie", "Se determina planul de executie cu un cost redus"]
            },
            {
                question: "Tehnica de clusterizare:",
                options: [
                    "Necesita suplimentare din partea SGBD pentru administrarea clusterului",
                    "Este o tehnica de grupare logica a doua sau mai multe tabele, relative la una sau mai multe coloane",
                    "Reduce costul de executie in cazul jonctiunilor pe cheia clusterului",
                    "Reduce timpul de actualizare a inregistrarilor",
                    "Cheia clusterului poate fi schimbata dupa popularea tabelelor"
                ],
                correctAnswers: ["Reduce costul de executie in cazul jonctiunilor pe cheia clusterului"]
            },
            {
                question: "Apelul unei functii PL/SQL din Python cu pachetul cx_Oracle se poate realiza:",
                options: [
                    "Prin callfunc() sau intr-un select",
                    "Prin execute_function()",
                    "Este necesar un cursor si precizarea tipului de data returnat de functie",
                    "Nu pot fi apelate functii create la nivelul bazei de date",
                    "Prin metoda execute"
                ],
                correctAnswers: ["Prin callfunc() sau intr-un select", "Este necesar un cursor si precizarea tipului de data returnat de functie"]
            },
             {
                question: "In SGBD Oracle instructiunea `select /*USE_MERGE (t ind)*/ t.id_client, t.nume_client from t_clienti t, t_comenzi ind;`",
                options: [
                    "Permite utilizarea indexului ind pe tabela t_clienti",
                    "Va apare o eroare",
                    "Reprezinta un comentariu",
                    "Realizeaza o jonctiune de egalitate prin aplicarea algoritmului SORT MERGE",
                    "Realizeaza un produs cartezian prin aplicarea algoritmului SORT MERGE"
                ],
                correctAnswers: ["Realizeaza un produs cartezian prin aplicarea algoritmului SORT MERGE"]
            },
            {
                question: "Metodele de analiza descriptiva:",
                options: [
                    "Se aplica de regula pe date prelucrate si structurate",
                    "Identifica principalele puncte slabe/forte si cauzele care le genereaza",
                    "Permit analiza evenimentelor istorice prin metrici, indicatori cheie de performanta (KPI), rapoarte integrate in tablouri de bord (dashboard)",
                    "Ofera o retrospectiva unica asupra datelor istorice"
                ],
                correctAnswers: ["Se aplica de regula pe date prelucrate si structurate", "Permit analiza evenimentelor istorice prin metrici, indicatori cheie de performanta (KPI), rapoarte integrate in tablouri de bord (dashboard)"]
            },
            {
                question: "Optiunea `indicator` a jonctiunii in Python (Pandas):",
                options: [
                    "Poate avea valoarea Left_only, Right_only, Both",
                    "Precizeaza coloana pe care se realizeaza jonctiunea",
                    "Indica tipul de jonctiune",
                    "Indica din ce set de date provin valorile inregistrarilor",
                    "Poate avea valoarea True, False, Both"
                ],
                correctAnswers: ["Poate avea valoarea Left_only, Right_only, Both", "Indica din ce set de date provin valorile inregistrarilor"]
            },
            {
                question: "Secventa `result.groupby(['ID_CLIENT']) ['VALOARE_DAUNA'].sum().nlargest (5)`:",
                options: [
                    "Grupeaza dupa id_client si insumeaza valoarea daunelor pentru primii 5 clienti care au id-urile cele mai mari",
                    "Grupeaza dupa id_client si insumeaza valoarea daunelor pentru primii 5 clienti care au valoarea insumata a daunelor cea mai mare",
                    "Genereaza o eroare deoarece groupby se utilizeaza atunci cand sunt cel putin doua coloane care necesita grupare",
                    "Genereaza o eroare deoarece lipseste agg",
                    "Grupeaza dupa id_client si insumeaza valoarea daunelor pentru cele mai mari 5 daune ale clientului respectiv"
                ],
                correctAnswers: ["Grupeaza dupa id_client si insumeaza valoarea daunelor pentru primii 5 clienti care au valoarea insumata a daunelor cea mai mare"]
            },
            {
                question: "Optiunea FLASHBACK din Oracle permite:",
                options: [
                    "Realizeaza copii ale bazei de date la intervale de timp regulate",
                    "Recuperarea unor inregistrari pe baza valorilor anterioare prin precizarea momentului de timp",
                    "Recuperarea obiectelor sterse",
                    "Vizualizarea tranzactiilor successive",
                    "Recuperarea tabelelor sterse"
                ],
                correctAnswers: ["Recuperarea unor inregistrari pe baza valorilor anterioare prin precizarea momentului de timp", "Recuperarea tabelelor sterse", "Recuperarea obiectelor sterse"]
            }
        ];
        
        // Adaugă proprietățile necesare pentru starea quiz-ului
        quizData.forEach(q => {
            q.userAnswers = [];
            q.answered = false;
        });

        let currentQuestionIndex = 0;
        const quizContainer = document.getElementById('quiz-container');
        const navigationButtons = document.getElementById('navigation-buttons');
        const prevButton = document.getElementById('prev-button');
        const nextButton = document.getElementById('next-button');
        const resultContainer = document.getElementById('result-container');

        function displayQuestion() {
            const currentQuestion = quizData[currentQuestionIndex];
            quizContainer.innerHTML = '';
            resultContainer.innerHTML = '';
            navigationButtons.style.display = 'flex';

            const questionElement = document.createElement('div');
            questionElement.className = 'mb-6';
            questionElement.innerHTML = `<p class="text-lg font-semibold text-gray-700">${currentQuestionIndex + 1}. ${currentQuestion.question}</p>`;
            if (!currentQuestion.answered) {
                 questionElement.innerHTML += `<p class="text-sm text-gray-500 mt-1">Selectați una sau mai multe opțiuni corecte.</p>`;
            }
            quizContainer.appendChild(questionElement);

            const optionsContainer = document.createElement('div');
            optionsContainer.className = 'space-y-3';
            quizContainer.appendChild(optionsContainer);

            currentQuestion.options.forEach((option, index) => {
                const optionId = `q${currentQuestionIndex}_option${index}`;
                const wrapper = document.createElement('div');
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = optionId;
                checkbox.value = option;
                checkbox.className = 'hidden';

                const label = document.createElement('label');
                label.htmlFor = optionId;
                label.textContent = option;
                label.className = 'option-label block w-full text-left bg-gray-100 hover:bg-gray-200 text-gray-800 font-medium py-3 px-4 rounded-lg border-2 border-transparent cursor-pointer transition-all';
                
                if (currentQuestion.userAnswers.includes(option)) {
                    label.classList.add('selected');
                    checkbox.checked = true;
                }

                checkbox.onchange = () => {
                    label.classList.toggle('selected');
                    updateUserAnswers(option);
                };
                
                if (currentQuestion.answered) {
                    checkbox.disabled = true;
                    // Stilizează răspunsurile după ce s-a verificat
                    if (currentQuestion.correctAnswers.includes(option)) {
                        label.classList.add('correct');
                    }
                    if (currentQuestion.userAnswers.includes(option) && !currentQuestion.correctAnswers.includes(option)) {
                        label.classList.add('incorrect');
                    }
                }

                wrapper.appendChild(checkbox);
                wrapper.appendChild(label);
                optionsContainer.appendChild(wrapper);
            });

            if (!currentQuestion.answered) {
                const checkButton = document.createElement('button');
                checkButton.id = 'check-answer-button';
                checkButton.textContent = 'Verifică Răspunsul';
                checkButton.className = 'mt-6 bg-green-500 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow';
                checkButton.onclick = checkAnswer;
                quizContainer.appendChild(checkButton);
            }
            
            updateNavigationButtons();
        }

        function updateUserAnswers(option) {
            const currentQuestion = quizData[currentQuestionIndex];
            const answerIndex = currentQuestion.userAnswers.indexOf(option);
            if (answerIndex > -1) {
                currentQuestion.userAnswers.splice(answerIndex, 1);
            } else {
                currentQuestion.userAnswers.push(option);
            }
        }
        
        function checkAnswer() {
            const currentQuestion = quizData[currentQuestionIndex];
            currentQuestion.answered = true;
            
            // Re-afișează întrebarea pentru a arăta stilurile corect/incorect
            displayQuestion(); 
            // Elimină butonul "Verifică" care e recreat în displayQuestion
            document.getElementById('check-answer-button')?.remove();
            
            updateNavigationButtons();
        }

        function updateNavigationButtons() {
            prevButton.disabled = currentQuestionIndex === 0;
            if (currentQuestionIndex === quizData.length - 1) {
                nextButton.textContent = 'Vezi Rezultatul';
                nextButton.disabled = !quizData.every(q => q.answered);
            } else {
                nextButton.textContent = 'Următor';
                nextButton.disabled = false;
            }
        }

        function showResults() {
            quizContainer.innerHTML = '';
            navigationButtons.style.display = 'none';

            let score = 0;
            quizData.forEach(q => {
                const userAnswersSorted = [...q.userAnswers].sort();
                const correctAnswersSorted = [...q.correctAnswers].sort();
                if (JSON.stringify(userAnswersSorted) === JSON.stringify(correctAnswersSorted)) {
                    score++;
                }
            });

            resultContainer.innerHTML = `<h2 class="text-2xl font-bold mb-4">Quiz Finalizat!</h2><p>Ai răspuns corect la ${score} din ${quizData.length} întrebări.</p>`;
            
            // Adaugă buton pentru a reîncepe testul
            const restartButton = document.createElement('button');
            restartButton.textContent = 'Reîncepe Testul';
            restartButton.className = 'mt-4 bg-indigo-500 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg shadow';
            restartButton.onclick = () => window.location.reload();
            resultContainer.appendChild(restartButton);
        }

        prevButton.addEventListener('click', () => {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayQuestion();
            }
        });

        nextButton.addEventListener('click', () => {
            if (currentQuestionIndex < quizData.length - 1) {
                currentQuestionIndex++;
                displayQuestion();
            } else {
                if (quizData.every(q => q.answered)) {
                    showResults();
                }
            }
        });

        // Afișează prima întrebare la încărcarea paginii
        displayQuestion();
    </script>

</body>
</html>
